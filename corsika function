#corsika function

   WEIGHT_KEY = "CorsikaWeightMap"
    MCTREE_KEY = 'I3MCTree'
    if year == 2012:
        PULSES_KEY = 'SplitInIcePulses'
        if dataset == 12379:
            weight_dtype = np.dtype(
            [
                ('AreaSum',np.float32),
                ('Atmosphere',np.float32),
                ('BackgroundI3MCPESeriesMapCount',np.float32),
                ('CylinderLength',np.float32),
                ('CylinderRadius',np.float32),
                ('EnergyPrimaryMax',np.float32),
                ('EnergyPrimaryMin',np.float32),
                ('FluxSum',np.float32),
                ('I3MCPESeriesMapCount',np.float32),
                ('Multiplicity',np.float32),
                ('NEvents',np.float32),
                ('OverSampling',np.float32),
                ('ParticleType',np.float32),
                ('Polygonato',np.float32),
                ('PrimaryEnergy',np.float32),
                ('PrimarySpectralIndex',np.float32),
                ('PrimaryType',np.int64),
                ('ThetaMax',np.float32),
                ('ThetaMin',np.float32),
                ('TimeScale',np.float32),
                ('Weight',np.float32),
            ]
            )
        else:
            weight_dtype = np.dtype(
            [
                ("AreaSum" ,np.float32),
                ("Atmosphere",np.float32),
                ("CylinderLength",np.float32),
                ("CylinderRadius" ,np.float32),
                ("DiplopiaWeight",np.float32),
                ("EnergyPrimaryMax",np.float32),
                ("EnergyPrimaryMin",np.float32),
                ("FluxSum",np.float32),
                ("Multiplicity",np.float32),
                ("NEvents",np.float32),
                ("OldWeight",np.float32),
                ("OverSampling",np.float32),
                ("Polygonato",np.float32),
                ("PrimaryEnergy",np.float32),
                ("PrimarySpectralIndex",np.float32),
                ("PrimaryType",np.int64),
                ("ThetaMax",np.float32),
                ("ThetaMin" ,np.float32),
                ("TimeScale",np.float32),
                ("Weight",np.float32)
            ]                            
            )    

    elif year == 2011:
        PULSES_KEY = 'OfflinePulses'
        if dataset == 10668:
            weight_dtype = np.dtype(
            [
                ('AreaSum',np.float32),
                ('Atmosphere',np.float32),
                ('CylinderLength',np.float32),
                ('CylinderRadius',np.float32),
                ('DiplopiaWeight',np.float32),
                ('EnergyPrimaryMax',np.float32),
                ('EnergyPrimaryMin',np.float32),
                ('FluxSum',np.float32),
                ('Multiplicity',np.float32),
                ('NEvents',np.float32),
                ('OldWeight',np.float32),
                ('Polygonato',np.float32),
                ('PrimaryEnergy',np.float32),
                ('PrimarySpectralIndex',np.float32),
                ('PrimaryType',np.int64),
                ('ThetaMax',np.float32),
                ('ThetaMin',np.float32),
                ('TimeScale',np.float32),
                ('Weight',np.float32)
            ]
            )       
        else:
            weight_dtype = np.dtype(
            [
                ('AreaSum',np.float32),
                ('Atmosphere',np.float32),
                ('CylinderLength',np.float32),
                ('CylinderRadius',np.float32),
                ('DiplopiaWeight',np.float32),
                ('EnergyPrimaryMax',np.float32),
                ('EnergyPrimaryMin',np.float32),
                ('FluxSum',np.float32),
                ('Multiplicity',np.float32),
                ('NEvents',np.float32),
                ('ParticleType',np.int64),
                ('Polygonato',np.float32),
                ('PrimarySpectralIndex',np.float32),
                ('TimeScale',np.float32),
                ('Weight',np.float32)
            ]
            )

    elif year == 2016:
        PULSES_KEY = 'SplitInIcePulses'
        MCTREE_KEY = 'I3MCTree_preMuonProp'
        weight_dtype = np.dtype(
            [
                ('AreaSum',np.float32),
                ('Atmosphere',np.float32),
                ('CylinderLength',np.float32),
                ('CylinderRadius',np.float32),
                ('EnergyPrimaryMax',np.float32),
                ('EnergyPrimaryMin',np.float32),
                ('FluxSum',np.float32),
                ('Multiplicity',np.float32),
                ('NEvents',np.float32),
                ('OverSampling',np.float32),
                ('ParticleType',np.int64),
                ('Polygonato',np.float32),
                ('PrimaryEnergy',np.float32),
                ('PrimarySpectralIndex',np.float32),
                ('PrimaryType',np.float32),
                ('ThetaMax',np.float32),
                ('ThetaMin',np.float32),
                ('TimeScale',np.float32),
                ('Weight',np.float32)
            ]
        )       

        w = dict(frame[WEIGHT_KEY])
        for key, val in w.items():
            if key in weight_dtype.names:
                weight[key] = val
#        3 lines above replace the 1 line below.  Idea is to only copy fields expected in weight_dtype.
#        The main quantities we care about are (I think):
#           OneWeight, PrimaryNeutrinoEnergy, InteractionType, PrimaryNeutrinoZenith, PrimaryNeutrinoType
#        weight[list(w.keys())] = tuple(w.values())


#muongun function

        w = frame['MuonWeight'].value
        event[["id","image","qtot","qst","primary","prim_daughter","logan_veto","hese","weight_val"]]=\
           (id[0], im, qtot, st_info, primary[0], prim_daughter[0], veto[0],hese[0], w)

        w = frame['MuonWeight'].value
        event[["id","image","qtot","qst","primary","prim_daughter","logan_veto","hese","weight_val"]]=\
           (id[0], im, qtot, st_info, primary[0], prim_daughter[0], veto[0],hese[0], w)
    else:
        event[["id","image","qtot","qst","primary","prim_daughter","trck_reco","cscd_reco","logan_veto","hese","weight_dict"]]=\
           (id[0], im, qtot, st_info, primary[0], prim_daughter[0],trck_reco[0],cscd_reco[0],veto[0],hese[0], weight[0])
#    print(event['qtot'],event['qst'],event['logan_veto'])
#    print(event['trck_reco'])



    info_dtype = np.dtype(
        [
            ("id", id_dtype),
            ("image", np.float32, (N_X_BINS, N_Y_BINS, N_CHANNELS)),
            ("qtot", np.float32),
            ("qst", st_info_dtype, N_CHANNELS),
            ("primary", particle_dtype),
            ("prim_daughter", particle_dtype),
            ("logan_veto", veto_dtype),                                                  
            ("hese", hese_dtype),
            ("weight_val", np.float32),        
        ]
    )

    muongun_nfiles={21317:9996,21316:9999,21315:15000}
    generator_set1_infile=glob.glob("/data/sim/IceCube/2016/generated/MuonGun/21315/0000000-0000999/*.i3.zst")
    generator_set1=harvest_generators([generator_set1_infile[0]]); infiles_set1 = muongun_nfiles[21315]
    generator_set2_infile=glob.glob("/data/sim/IceCube/2016/generated/MuonGun/21316/0000000-0000999/*.i3.zst")
    generator_set2=harvest_generators([generator_set2_infile[0]]); infiles_set2 = muongun_nfiles[21316]
    generator_set3_infile=glob.glob("/data/sim/IceCube/2016/generated/MuonGun/21317/0000000-0000999/*.i3.zst")
    generator_set3=harvest_generators([generator_set3_infile[0]]); infiles_set3 = muongun_nfiles[21317]
    mg_generator=((infiles_set1*generator_set1) +
               (infiles_set2*generator_set2) +
               (infiles_set3*generator_set3))
    mg_model = MuonGun.load_model('GaisserH4a_atmod12_SIBYLL')



    passed = has_header and has_weights and has_rawdata and has_mctree and has_pulses 
    if passed:
#        print("PASSES")
        if data_type == 'genie': #Keep only events with right interaction type
            if frame[WEIGHT_KEY]['InteractionType'] != it:
                return False


#data function

        save = []
        calib = frame['I3Calibration']
        status = frame['I3DetectorStatus']
        width = 3.33334
        for om, ps in pulses.items():

            if not om.string in st_info['num']:
                continue

            if om in wf_map:
                has_good_wf = False
                for wf in wf_map.get(om, []):
                    if wf.status == 0:
                        has_good_wf = True
                if has_good_wf:
                    continue

                    
            chl = np.where(st_info['num'] == om.string)
            p_time = np.min([i.time for i in ps])
            min_time = p_time - width*15
            max_time = p_time + width*112
            times = np.linspace(min_time, max_time, 128)

            cal = calib.dom_cal[om]
            stat = status.dom_status[om]
            wf_vals=wavereform.refold_pulses(ps, I3Waveform.ATWD, 0, cal, stat, times, False)
            
            wfms.append({
                    'wfm': wf_vals,
                    'time': min_time,  
                    'width': width,
                    'dom_idx': om.om - 1,
                    'img_ch': chl[0][0],
                    'om_pos': [geometry[om].position.x,geometry[om].position.y,geometry[om].position.z]
                    })








 
elif data_type == 'muongun':
    WEIGHT_KEY = 'None'
    PULSES_KEY = 'SplitInIcePulses'
    MCTREE_KEY = 'I3MCTree_preMuonProp'
    weight_dtype = np.dtype(
        [
            ('ThisisData',np.float32),
        ]
    )  


else: #data
    WEIGHT_KEY = 'None'
    PULSES_KEY = 'SplitInIcePulses'
    MCTREE_KEY = 'None'
    weight_dtype = np.dtype(
        [
            ('ThisisData',np.float32),
        ]
    )  

#Output data format         
if data_type == 'muongun':

     
else:
    info_dtype = np.dtype(
        [
            ("id", id_dtype),
            ("image", np.float32, (N_X_BINS, N_Y_BINS, N_CHANNELS)),
            ("qtot", np.float32),
            ("qst", st_info_dtype, N_CHANNELS),
            ("primary", particle_dtype),
            ("prim_daughter", particle_dtype),
            ("trck_reco", particle_dtype),
            ("cscd_reco", particle_dtype),
            ("logan_veto", veto_dtype),                                                  
            ("hese", hese_dtype),
            ("weight_dict", weight_dtype),        
        ]
    )











if not data_type == 'data':
    #find primary particle
        mctree = frame[MCTREE_KEY]
        daughter = None
        if data_type == 'genie':
            prim = dataclasses.get_most_energetic_neutrino(mctree)
            
            max_energy = 0
            for part in mctree.children(prim.id):
                if (part.energy > max_energy) and (abs(part.pdg_encoding) in [11,12,13,14,15,16,17,18]):
                    max_enegy = part.energy
                    daughter = part
        else:
            prim = dataclasses.get_most_energetic_primary(mctree)
            daughter = dataclasses.get_most_energetic_muon(mctree)
           


